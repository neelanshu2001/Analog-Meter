{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport React, { useContext, useMemo } from 'react';\nimport { polarToCartesian } from \"./utils\";\nimport { G, Line, Text } from 'react-native-svg';\nimport Context from \"./context\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\n\nvar getMarkPosition = function getMarkPosition(angle, offset, radius) {\n  return polarToCartesian(radius, radius, radius + offset, angle);\n};\n\nexport default function Marks(_ref) {\n  var _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 10 : _ref$step,\n      _ref$lineCap = _ref.lineCap,\n      lineCap = _ref$lineCap === void 0 ? 'butt' : _ref$lineCap,\n      _ref$lineColor = _ref.lineColor,\n      lineColor = _ref$lineColor === void 0 ? 'white' : _ref$lineColor,\n      _ref$lineOpacity = _ref.lineOpacity,\n      lineOpacity = _ref$lineOpacity === void 0 ? 1 : _ref$lineOpacity,\n      _ref$numbersRadius = _ref.numbersRadius,\n      numbersRadius = _ref$numbersRadius === void 0 ? 17 : _ref$numbersRadius,\n      _ref$fontSize = _ref.fontSize,\n      fontSize = _ref$fontSize === void 0 ? 18 : _ref$fontSize,\n      _ref$lineSize = _ref.lineSize,\n      lineSize = _ref$lineSize === void 0 ? 12 : _ref$lineSize,\n      children = _ref.children;\n\n  var _useContext = useContext(Context),\n      rotation = _useContext.rotation,\n      min = _useContext.min,\n      max = _useContext.max,\n      angle = _useContext.angle,\n      radius = _useContext.radius,\n      fontFamily = _useContext.fontFamily;\n\n  var marks = useMemo(function () {\n    var stepsLength = Math.round((max - min) / step);\n    var gap = angle / stepsLength;\n    return _toConsumableArray(Array(stepsLength + 1)).map(function (val, index) {\n      var actualAngle = gap * index;\n      var isEven = index % 2 == 0;\n      var size = isEven ? lineSize : lineSize - 5;\n\n      var _getMarkPosition = getMarkPosition(actualAngle, 0, radius),\n          x1 = _getMarkPosition.x,\n          y1 = _getMarkPosition.y;\n\n      var _getMarkPosition2 = getMarkPosition(actualAngle, -size, radius),\n          x2 = _getMarkPosition2.x,\n          y2 = _getMarkPosition2.y;\n\n      var _getMarkPosition3 = getMarkPosition(actualAngle, -lineSize - numbersRadius, radius),\n          x = _getMarkPosition3.x,\n          y = _getMarkPosition3.y;\n\n      return {\n        coordinates: {\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2\n        },\n        isEven: isEven,\n        textProps: {\n          x: x,\n          y: y,\n          transform: \"rotate(\" + (360 - rotation) + \", \" + x + \", \" + y + \")\"\n        },\n        value: Math.round(index * step + min)\n      };\n    });\n  }, [max, min, step, radius, rotation, angle, lineSize]);\n  if (children) return _jsx(_Fragment, {\n    children: marks.map(children)\n  });\n  return _jsx(_Fragment, {\n    children: marks.map(function (mark, i) {\n      return _jsxs(G, {\n        children: [_jsx(Line, _objectSpread(_objectSpread({}, mark.coordinates), {}, {\n          stroke: lineColor,\n          strokeWidth: mark.isEven ? 3 : 2,\n          strokeOpacity: lineOpacity,\n          strokeLinecap: lineCap\n        })), mark.isEven && _jsx(Text, _objectSpread(_objectSpread({}, mark.textProps), {}, {\n          fill: \"white\",\n          textAnchor: \"middle\",\n          alignmentBaseline: \"middle\",\n          fontFamily: fontFamily,\n          opacity: 0.8,\n          fontSize: fontSize,\n          children: mark.value\n        }))]\n      }, i);\n    })\n  });\n}","map":{"version":3,"names":["React","useContext","useMemo","polarToCartesian","G","Line","Text","Context","getMarkPosition","angle","offset","radius","Marks","step","lineCap","lineColor","lineOpacity","numbersRadius","fontSize","lineSize","children","rotation","min","max","fontFamily","marks","stepsLength","Math","round","gap","Array","map","val","index","actualAngle","isEven","size","x1","x","y1","y","x2","y2","coordinates","textProps","transform","value","mark","i"],"sources":["E:/intern/meter/node_modules/react-native-cool-speedometer/dist/Marks.js"],"sourcesContent":["import React, { useContext, useMemo } from 'react';\nimport { polarToCartesian } from './utils';\nimport { G, Line, Text } from 'react-native-svg';\nimport Context from './context';\nconst getMarkPosition = (angle, offset, radius) => {\n    return polarToCartesian(radius, radius, radius + offset, angle);\n};\nexport default function Marks({ step = 10, lineCap = 'butt', lineColor = 'white', lineOpacity = 1, numbersRadius = 17, fontSize = 18, lineSize = 12, children, }) {\n    const { rotation, min, max, angle, radius, fontFamily } = useContext(Context);\n    const marks = useMemo(() => {\n        const stepsLength = Math.round((max - min) / step);\n        const gap = angle / stepsLength;\n        return [...Array(stepsLength + 1)].map((val, index) => {\n            const actualAngle = gap * index;\n            const isEven = index % 2 == 0;\n            const size = isEven ? lineSize : lineSize - 5;\n            const { x: x1, y: y1 } = getMarkPosition(actualAngle, 0, radius);\n            const { x: x2, y: y2 } = getMarkPosition(actualAngle, -size, radius);\n            const { x, y } = getMarkPosition(actualAngle, -lineSize - numbersRadius, radius);\n            return {\n                coordinates: { x1, y1, x2, y2 },\n                isEven,\n                textProps: { x, y, transform: `rotate(${360 - rotation}, ${x}, ${y})` },\n                value: Math.round((index * step) + min)\n            };\n        });\n    }, [max, min, step, radius, rotation, angle, lineSize]);\n    if (children)\n        return (<>\n      {marks.map(children)}\n    </>);\n    return (<>\n      {marks.map((mark, i) => (<G key={i}>\n          <Line {...mark.coordinates} stroke={lineColor} strokeWidth={mark.isEven ? 3 : 2} strokeOpacity={lineOpacity} strokeLinecap={lineCap}/>\n          {mark.isEven && (<Text {...mark.textProps} fill=\"white\" textAnchor=\"middle\" alignmentBaseline=\"middle\" fontFamily={fontFamily} opacity={0.8} fontSize={fontSize} children={mark.value}/>)}\n        </G>))}\n    </>);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}